{"version":3,"sources":["utils.js","constants.js","components/TheTime.js","components/NextTimes.js","components/FromTo.js","App.js","serviceWorker.js","index.js"],"names":["token","accessToken","expires","getData","from","destination","a","async","isTokenValid","setToken","fetchData","response","status","json","data","DepartureBoard","Departure","to","getTime","date","time","tripUrl","fetch","method","headers","Authorization","Date","fetchAccessToken","getExpireTime","expires_in","access_token","secondsToExpires","setSeconds","getSeconds","body","now","toISOString","substr","toTimeString","partillePort","name","id","nordstan","TheTime","props","timeTable","realTime","rtTime","className","NextTimes","icon","faBus","FromTo","handleSwap","onClick","faExchangeAlt","App","useState","setTimeTable","setFrom","setDestionation","getTimeTable","useCallback","useEffect","tempFrom","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.8f462401.chunk.js","sourcesContent":["var token = { accessToken: \"\", expires: null }\r\nconst id =\r\n  \"T0hDc2txdEp6cDhMYlVmRjhsaWVfeERHdDBBYTp6ME5wWWY3dlYxbUFhTEVFbkdyRFprTGEwODBh\"\r\n\r\nexport const getData = async (from, destination) => {\r\n  let data\r\n  if (!isTokenValid()) {\r\n    await setToken()\r\n  }\r\n  let response = await fetchData(from, destination)\r\n  if (response.status === 401) {\r\n    await setToken()\r\n    response = await fetchData(from, destination)\r\n  }\r\n  if (response.status === 200) {\r\n    data = await response.json()\r\n    return data.DepartureBoard.Departure\r\n  }\r\n  return data\r\n}\r\n\r\nconst fetchData = async (from, to) => {\r\n  const { date, time } = getTime()\r\n  const tripUrl = `https://api.vasttrafik.se/bin/rest.exe/v2/departureBoard?id=${from}&direction=${to}&date=${date}&time=${time}&format=json`\r\n  const response = await fetch(tripUrl, {\r\n    method: \"GET\",\r\n    headers: {\r\n      Authorization: `Bearer ${token.accessToken}`\r\n    }\r\n  })\r\n  return response\r\n}\r\n\r\nconst isTokenValid = () => {\r\n  if (!token.accessToken) return false\r\n  if (token.expires && token.expires < new Date()) return false\r\n  return true\r\n}\r\n\r\nconst setToken = async () => {\r\n  const data = await fetchAccessToken()\r\n  const expires = getExpireTime(data.expires_in)\r\n  const accessToken = data.access_token\r\n  token = { accessToken, expires }\r\n}\r\n\r\nconst getExpireTime = secondsToExpires => {\r\n  let date = new Date()\r\n  date.setSeconds(date.getSeconds() + secondsToExpires)\r\n  return date\r\n}\r\n\r\nconst fetchAccessToken = async () => {\r\n  const response = await fetch(\"https://api.vasttrafik.se:443/token\", {\r\n    headers: {\r\n      Authorization: `Basic ${id}`,\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n    },\r\n    method: \"POST\",\r\n    body: \"grant_type=client_credentials\"\r\n  })\r\n  const data = await response.json()\r\n  return data\r\n}\r\n\r\nconst getTime = () => {\r\n  //Todo gets the buses from exactly now. Will it show late busses pass the time?\r\n  const now = new Date()\r\n  const date = now.toISOString().substr(0, 10)\r\n  const time = now.toTimeString().substr(0, 5)\r\n  return { date, time }\r\n}\r\n","const partillePortId = \"9022014013213001\"\r\nconst nordstanId = \"9021014004945000\"\r\nexport const partillePort = {\r\n  name: \"Partille Port\",\r\n  id: partillePortId\r\n}\r\nexport const nordstan = {\r\n  name: \"GÃ¶teborg Nordstan\",\r\n  id: nordstanId\r\n}\r\n","import React from \"react\"\r\n\r\nconst TheTime = props => {\r\n  const { timeTable } = props\r\n  const time = timeTable[0].time\r\n  const realTime = timeTable[0].rtTime\r\n  return (\r\n    <div className=\"TheTime\">\r\n      <div className=\"TheTimeBlock\" />\r\n      <div className=\"TheTimeBlock\">\r\n        <h1 className=\"nextBusTime\">{time}</h1>\r\n      </div>\r\n      <div className=\"TheTimeBlock\">\r\n        {time !== realTime || true ? (\r\n          <h2 className=\"realTime\">({realTime})</h2>\r\n        ) : (\r\n          \"\"\r\n        )}\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default TheTime\r\n","import React from \"react\"\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\r\nimport { faBus } from \"@fortawesome/free-solid-svg-icons\"\r\n\r\nconst NextTimes = props => {\r\n  const { timeTable } = props\r\n  return (\r\n    <div>\r\n      <p>\r\n        <FontAwesomeIcon className=\"busIcon\" icon={faBus} />\r\n        {timeTable[1].time}\r\n      </p>\r\n      <p>\r\n        <FontAwesomeIcon className=\"busIcon\" icon={faBus} />\r\n        {timeTable[2].time}\r\n      </p>\r\n      <p>\r\n        <FontAwesomeIcon className=\"busIcon\" icon={faBus} />\r\n        {timeTable[3].time}\r\n      </p>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default NextTimes\r\n","import React from \"react\"\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\r\nimport { faArrowRight, faExchangeAlt } from \"@fortawesome/free-solid-svg-icons\"\r\n\r\nconst FromTo = props => {\r\n  const { handleSwap, from, destination } = props\r\n  return (\r\n    <div className=\"fromToWrapper\">\r\n      <div className=\"fromTo\">\r\n        <h3 className=\"from\" onClick={handleSwap}>\r\n          {from.name}\r\n        </h3>{\" \"}\r\n        <FontAwesomeIcon\r\n          className=\"exchangeArrows\"\r\n          onClick={handleSwap}\r\n          icon={faExchangeAlt}\r\n        />\r\n        <h3 className=\"to\">{destination.name}</h3>\r\n      </div>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default FromTo\r\n","import React, { useEffect, useState, useCallback, Fragment } from \"react\"\nimport \"./App.css\"\nimport { getData } from \"./utils\"\nimport { partillePort, nordstan } from \"./constants\"\nimport TheTime from \"./components/TheTime\"\nimport NextTimes from \"./components/NextTimes\"\nimport FromTo from \"./components/FromTo\"\n\nfunction App() {\n  const [timeTable, setTimeTable] = useState()\n  const [from, setFrom] = useState(partillePort)\n  const [destination, setDestionation] = useState(nordstan)\n\n  const getTimeTable = useCallback(async () => {\n    const data = await getData(from.id, destination.id)\n    setTimeTable(data)\n  }, [from, destination])\n\n  useEffect(() => {\n    getTimeTable()\n  }, [getTimeTable])\n\n  const handleSwap = () => {\n    const tempFrom = from\n    const tempDestination = destination\n    setFrom(tempDestination)\n    setDestionation(tempFrom)\n  }\n\n  return (\n    <Fragment>\n      {timeTable ? (\n        <div className=\"App\">\n          <div className=\"TimeTable\">\n            <TheTime timeTable={timeTable} />\n            <NextTimes timeTable={timeTable} />\n          </div>\n          <FromTo\n            handleSwap={handleSwap}\n            from={from}\n            destination={destination}\n          />\n        </div>\n      ) : (\n        \"\"\n      )}\n    </Fragment>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}