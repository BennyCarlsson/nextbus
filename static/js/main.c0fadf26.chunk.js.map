{"version":3,"sources":["utils.js","constants.js","App.js","serviceWorker.js","index.js"],"names":["token","accessToken","expires","getData","from","destination","a","async","isTokenValid","setToken","fetchData","response","status","json","data","DepartureBoard","Departure","to","getTime","date","time","tripUrl","fetch","method","headers","Authorization","Date","fetchAccessToken","getExpireTime","expires_in","access_token","secondsToExpires","setSeconds","getSeconds","body","now","toISOString","substr","toTimeString","partillePort","name","id","nordstan","App","useState","timeTable","setTimeTable","setFrom","setDestionation","getTimeTable","useCallback","useEffect","handleSwap","tempFrom","className","rtTime","onClick","icon","faArrowRight","faExchangeAlt","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c0fadf26.chunk.js","sourcesContent":["var token = { accessToken: \"\", expires: null }\r\nconst id =\r\n  \"T0hDc2txdEp6cDhMYlVmRjhsaWVfeERHdDBBYTp6ME5wWWY3dlYxbUFhTEVFbkdyRFprTGEwODBh\"\r\n\r\nexport const getData = async (from, destination) => {\r\n  let data\r\n  if (!isTokenValid()) {\r\n    await setToken()\r\n  }\r\n  let response = await fetchData(from, destination)\r\n  if (response.status === 401) {\r\n    await setToken()\r\n    response = await fetchData(from, destination)\r\n  }\r\n  if (response.status === 200) {\r\n    data = await response.json()\r\n    return data.DepartureBoard.Departure\r\n  }\r\n  return data\r\n}\r\n\r\nconst fetchData = async (from, to) => {\r\n  const { date, time } = getTime()\r\n  const tripUrl = `https://api.vasttrafik.se/bin/rest.exe/v2/departureBoard?id=${from}&direction=${to}&date=${date}&time=${time}&format=json`\r\n  const response = await fetch(tripUrl, {\r\n    method: \"GET\",\r\n    headers: {\r\n      Authorization: `Bearer ${token.accessToken}`\r\n    }\r\n  })\r\n  return response\r\n}\r\n\r\nconst isTokenValid = () => {\r\n  if (!token.accessToken) return false\r\n  if (token.expires && token.expires < new Date()) return false\r\n  return true\r\n}\r\n\r\nconst setToken = async () => {\r\n  const data = await fetchAccessToken()\r\n  const expires = getExpireTime(data.expires_in)\r\n  const accessToken = data.access_token\r\n  token = { accessToken, expires }\r\n}\r\n\r\nconst getExpireTime = secondsToExpires => {\r\n  let date = new Date()\r\n  date.setSeconds(date.getSeconds() + secondsToExpires)\r\n  return date\r\n}\r\n\r\nconst fetchAccessToken = async () => {\r\n  const response = await fetch(\"https://api.vasttrafik.se:443/token\", {\r\n    headers: {\r\n      Authorization: `Basic ${id}`,\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n    },\r\n    method: \"POST\",\r\n    body: \"grant_type=client_credentials\"\r\n  })\r\n  const data = await response.json()\r\n  return data\r\n}\r\n\r\nconst getTime = () => {\r\n  //Todo gets the buses from exactly now. Will it show late busses pass the time?\r\n  const now = new Date()\r\n  const date = now.toISOString().substr(0, 10)\r\n  const time = now.toTimeString().substr(0, 5)\r\n  return { date, time }\r\n}\r\n","const partillePortId = \"9022014013213001\"\r\nconst nordstanId = \"9021014004945000\"\r\nexport const partillePort = {\r\n  name: \"Partille Port\",\r\n  id: partillePortId\r\n}\r\nexport const nordstan = {\r\n  name: \"GÃ¶teborg Nordstan\",\r\n  id: nordstanId\r\n}\r\n","import React, { useEffect, useState, useCallback } from \"react\"\nimport \"./App.css\"\nimport { getData } from \"./utils\"\nimport { partillePort, nordstan } from \"./constants\"\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\"\nimport { faArrowRight, faExchangeAlt } from \"@fortawesome/free-solid-svg-icons\"\n\nfunction App() {\n  const [timeTable, setTimeTable] = useState()\n  const [from, setFrom] = useState(partillePort)\n  const [destination, setDestionation] = useState(nordstan)\n\n  const getTimeTable = useCallback(async () => {\n    const data = await getData(from.id, destination.id)\n    setTimeTable(data)\n  }, [from, destination])\n\n  useEffect(() => {\n    getTimeTable()\n  }, [getTimeTable])\n\n  const handleSwap = () => {\n    const tempFrom = from\n    const tempDestination = destination\n    setFrom(tempDestination)\n    setDestionation(tempFrom)\n  }\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h2>\n          {timeTable && timeTable[0].time} ({timeTable && timeTable[0].rtTime})\n        </h2>\n        <p>{timeTable && timeTable[1].time}</p>\n        <p>{timeTable && timeTable[2].time}</p>\n        <p>{timeTable && timeTable[3].time}</p>\n        <h3 onClick={handleSwap}>\n          {from.name} <FontAwesomeIcon icon={faArrowRight} /> {destination.name}\n        </h3>\n        <FontAwesomeIcon\n          className=\"exchangeArrows\"\n          onClick={handleSwap}\n          icon={faExchangeAlt}\n        />\n      </header>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}